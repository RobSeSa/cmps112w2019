#!/usr/bin/perl
# Robert Sato (rssato)
# Huanlei Wu (hwu43)

use strict;
use warnings;
use Getopt::Std;
$0 =~ s|.*/||;

# signals and their description
my %strsignal = (
    1 => "Hangup",
    2 => "Interrupt",
    3 => "Quit",
    4 => "Illegal instruction",
    5 => "Trace/breakpoint trap",
    6 => "Aborted",
    7 => "Bus error",
    8 => "Floating point exception",
    9 => "Killed",
   11 => "Segmentation fault",
   13 => "Broken pipe",
   14 => "Alarm clock",
   15 => "Terminated",
   16 => "Stack fault",
   17 => "Child exited",
   18 => "Continued",
   19 => "Stopped (signal)",
   20 => "Stopped",
   21 => "Stopped (tty input)",
   22 => "Stopped (tty output)",
   24 => "CPU time limit exceeded",
   25 => "File size limit exceeded",
   26 => "Virtual timer expired",
   27 => "Profiling timer expired",
   28 => "Window changed",
   29 => "I/O possible",
   30 => "Power failure",
   31 => "Bad system call",
);

# sees if flag d is typed in command line
# if flag d is set, $opt_d will be true
getopts('d');

# parses a line of the given file
# word before the colon is the target
# word(s) after the colon are the dependencies
sub targetAndDep ($) {
   my ($line) = @_;
   return undef unless $line =~ m/^(\S+)\s*:\s*(.*?)\s*$/;
   my ($target, $dependency) = ($1, $2);
   my @dependencies = split m/\s+/, $dependency;
   return $target, \@dependencies;
}

sub mtime($) {
   my ($filename) = @_;
   return undef unless defined $filename;
   my @stat = stat $filename;
   return @stat ? $stat[9] : undef;
}

sub command ($$) {

}

sub getMacro ($) {
   my ($line) = @_;
   $line =~ m/^(\S+)\s*=\s*(.*?)\s*$/;
   my ($var, $val) = ($1, $2);
   my @values = split m/\s+/, $val;
   return $var, \@values;
}

my %deps;       # hash table to store target and dependencies
my %commands;   # hash table to store target and commands
my %macro;      # hash table to store macros
my $target;     # keeps track of the target

# goes through the whole Makefile
# uses function parse_dep to parse each line of the file
open(FILE, 'Makefile') || die("Could not open Makefile\n");
while (my $line = <FILE>) {
   my $deps;
   # line is a comment
   if ($line =~ m/^#.*$/) {
      # do nothing
   # line contains a target and dependencies
   } elsif ($line =~ m/^\S+\s*:\s*.*?\s*$/) {
      ($target, $deps) = targetAndDep $line;
      $deps{$target} = $deps;
   # line contains macro
   } elsif ($line =~ m/^\S+\s*=\s*.*?\s*$/) {
      my ($var, $val) = getMacro $line;
      $macro{$var} = $val;
   # line contains command
   } elsif ($line =~ m/^\t(.*)\s*$/) {
      $commands{$target} = $1;
   }
}

# compares given target with given dependency
sub timeCompare ($$) {
   my ($mytarget, $var) = (@_);
   my $target_time = mtime $mytarget;
   if($target_time){
      print "$mytarget time = $target_time\n";
   }
   else {
      print "$mytarget time is undefined\n";
   }
   my $var_time = mtime $var;
   print "var: $var\n";
   print "$var time = $var_time\n";
   if(! defined $var_time) {
      print "$var does not exist\n";
   }
   else {
      my $difference = $var_time - $target_time;
      print "difference: $difference\n";
      if($difference > 0){
         print "$var needs to be compiled\n$var edited $difference after $mytarget\n";
         return 1;
      }
      else{
         print "no need to recompile $var as $var edited $difference after $mytarget\n";
         return 0;
      }
   }
}

# compares all interior dependencies for time discrepancies
sub tree_time_cmp($) {
   my ($mytarget) = @_;
   if (! exists $deps{$mytarget}) {
      print "here\n";
      return 0;
   } else {
      my $dependency = $deps{$mytarget};
      foreach my $var (@$dependency) {
         if (timeCompare ($mytarget, $var)) {
            return 1;
         } else {
            if (tree_time_cmp $var) {
               return 1;
            }
         }
      }
      return 0;
   }
}

tree_time_cmp "goodbye";
