#!/usr/bin/perl
# Robert Sato (rssato)
# Huanlei Wu (hwu43)

use strict;
use warnings;
use Getopt::Std;
my %OPTS;
getopts ("d", \%OPTS);
$0 =~ s|.*/||;

# signals and their description
my %strsignal = (
    1 => "Hangup",
    2 => "Interrupt",
    3 => "Quit",
    4 => "Illegal instruction",
    5 => "Trace/breakpoint trap",
    6 => "Aborted",
    7 => "Bus error",
    8 => "Floating point exception",
    9 => "Killed",
   11 => "Segmentation fault",
   13 => "Broken pipe",
   14 => "Alarm clock",
   15 => "Terminated",
   16 => "Stack fault",
   17 => "Child exited",
   18 => "Continued",
   19 => "Stopped (signal)",
   20 => "Stopped",
   21 => "Stopped (tty input)",
   22 => "Stopped (tty output)",
   24 => "CPU time limit exceeded",
   25 => "File size limit exceeded",
   26 => "Virtual timer expired",
   27 => "Profiling timer expired",
   28 => "Window changed",
   29 => "I/O possible",
   30 => "Power failure",
   31 => "Bad system call",
);

# sees if flag d is typed in command line
# if flag d is set, $opt_d will be true
getopts('d');
if ($OPTS{'d'}) {
   print ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n
          IN DEBUG MODE\n\n"
}

my %deps;       # hash table to store target and dependencies
my %commands;   # hash table to store target and commands
my %macro;      # hash table to store macros
my $target;     # keeps track of the target
my $first_flag = 1;
my $first_target;

sub replace {
   my ($line) = @_;
   while ($line =~ m/^.*?\${(.*?)}.*$/ || $line =~ m/\$\$/) {
      my $replaced = $macro{$1};
      print "replacing $1 with $replaced\n" if ($OPTS{'d'});
      if ($line =~ m/^.*?\${(.*?)}.*$/) {
         $line =~ s/\${$1}/$replaced/g;
      }
      else {
         $line =~ s/\$\$/\$/g;
      }
   }
   return $line;
}

# parses a line of the given file
# word before the colon is the target
# word(s) after the colon are the dependencies
sub targetAndDep ($) {
   my ($line) = @_;
   return undef unless $line =~ m/^(\S+)\s*:\s*(.*?)\s*$/;
   my $target = replace $1;
   my $dependency = replace $2;
   my @dependencies = split m/\s+/, $dependency;
   return $target, \@dependencies;
}

sub mtime($) {
   my ($filename) = @_;
   return undef unless defined $filename;
   my @stat = stat $filename;
   return @stat ? $stat[9] : undef;
}

sub getMacro {
   my ($line) = @_;
   if ($line =~ m/^(\S+)\s*=\s*(.*?)\s*$/) {
      my $replaced = replace $2;
      return ($1, $replaced);
   } else {
      print "\"$line\" is not a macro\n\n" if ($OPTS{'d'});
      return undef;
   }
}



# goes through the whole Makefile
# uses function parse_dep to parse each line of the file
open(FILE, 'Makefile') || die("Could not open Makefile\n");
while (my $line = <FILE>) {
   my $deps;
   # line is a comment
   if ($line =~ m/^#.*$/) {
      # do nothing
   # line contains a target and dependencies
   } elsif ($line =~ m/^\S+\s*:\s*.*?\s*$/) {
      ($target, $deps) = targetAndDep $line;
      $deps{$target} = $deps;
      if($first_flag) {
         $first_target = $target;
         $first_flag = 0;
      }
   # line contains macro
   } elsif ($line =~ m/^\S+\s*=\s*.*?\s*$/) {
      my ($var, $val) = getMacro $line;
      $macro{$var} = $val;
   # line contains command
   } elsif ($line =~ m/^\t(.*)\s*$/) {
      if (exists $commands{$target}) {
         my $array = $commands{$target};
         my $replaced = replace $1;
         push (@$array, $replaced);
         $commands{$target} = $array;
      } else {
         my $replaced = replace $1;
         my @newArr = ($replaced);
         $commands{$target} = \@newArr;
      }
   }
}
close(FILE);


# compares given target with given dependency
sub timeCompare ($$) {
   my ($mytarget, $var) = (@_);
   my $target_time = mtime $mytarget;
   if($target_time){
      print "$mytarget time = $target_time\n" if ($OPTS{'d'});
   }
   #if target time not defined target is just a target and not a file
   #therefore all of its dependencies and commands should be executed
   else {
      print "$mytarget time is undefined\n" if ($OPTS{'d'});
      return 1;
   }
   my $var_time = mtime $var;
   print "var: $var\n" if ($OPTS{'d'});
   print "$var time = $var_time\n" if ($OPTS{'d'});
   if(! defined $var_time) {
      #print "vartime = $var_time\n";
      #print "$var does not exist\n";
      return 1;
   }
   else {
      my $difference = $var_time - $target_time;
      print "difference: $difference\n" if ($OPTS{'d'});
      if($difference > 0){
         print "$var needs to be compiled\n$var edited $difference after $mytarget\n" if ($OPTS{'d'});
         return 1;
      }
      else{
         print "no need to recompile $var as $var edited $difference after $mytarget\n" if ($OPTS{'d'});
         return 0;
      }
   }
}

# compares all interior dependencies for time discrepancies
sub tree_time_cmp {
   my ($mytarget) = @_;
   if (! exists $deps{$mytarget}) {
      print "\$deps{$mytarget} DNE returning 0..\n" if ($OPTS{'d'});
      return 0;
   } else {
      my $dependency = $deps{$mytarget};
      foreach my $var (@$dependency) {
         if (timeCompare ($mytarget, $var)) {
            return 1;
         } else {
            #print "\$var = $var\n";
            if (tree_time_cmp ($var)) {
               #print "tree_time_cmp $var was true!\n returning 1..\n";
               return 1;
            }
         }
      }
      return 0;
   }
}

sub error_handle{
   print "\$? = $?\n" if ($OPTS{'d'});
   if ($? != 0) {
      my $term_signal = $? & 0x7F;
      my $core_dumped = $? & 0x80;
      print "\nExiting core was dumped...\n" if ($core_dumped and $OPTS{'d'});
      my $exit_status = ($? >> 8) & 0xFF;
      print "Exit status = $exit_status\n" if ($OPTS{'d'});
      if ($term_signal) {
         my $signal = $strsignal{$term_signal};
         print "\nTermination signal = $term_signal\n$signal...\n";
      }
      exit;
   }
}

sub exec_cmd {
   my ($target) = @_;
   #print "target = $target\n";
   my $command = $commands{$target};
   foreach my $var (@$command) {
      if (defined $var){
         print "Executing commands: \"$var\" under target: $target\n" if ($OPTS{'d'});
         my $prereq = $deps{$target};
         my @preArr = @$prereq;
         my $first = $preArr[0];
         print "first = $first\n" if ($OPTS{'d'});
         $var =~ s/\$</$first/;
         $var =~ s/\$@/$target/;
         if ($var =~ m/^@\s*(.*?)\s*$/) {
            system($1);
            error_handle;
         }
         elsif ($var =~ m/^-\s*(.*?)\s*$/) {
            print "$1\n";
            system($1);
         } else {
            print "$var\n";
            system ($var);
            error_handle;
         }
      }
      else {
         #print "$target has no commands\n";
      }
   }
}
sub interp_target {
   my ($mytarget) = @_;
   #print "interpreting $mytarget...\n";
   if ((! exists $deps{$mytarget}) && (! defined $mytarget))  {
      print ";;;;;;; ERROR;;;;;;;\n$mytarget not found in dep table or directory\n";
   }
   else {
      if (! exists $deps{$mytarget}) {
         # check to see if there is a wildcard that can execute the given target
         $mytarget =~ m/^\s*(\w+?)(\.\w+?)$/;
         my $suffix = undef;
         # goes through the deps hash table to see if wildcard exists
         foreach my $keys (keys %deps) {
            if ($keys eq "%$2") { 
               $suffix = $keys;
               last;
            }
         }
         # if wildcard exists, interpret the target
         if (defined $suffix) {
            my $dependency = $deps{$suffix};
            # put a number that is not 1 or 2 because timeCompare returns 1 or 2
            # if firstTarget still equals 2 at the end, target's commands still needs to execute
            my $firstTarget = 2;
            # checks to see if the dependencies are up to date
            # if they aren't, update them using interp_target
            foreach my $var (@$dependency) {
               $var =~ s/%/$1/;
               $firstTarget = timeCompare ($mytarget, $var);
               if ($firstTarget == 1) {
                  interp_target ($var);
               }
            }
            if ($firstTarget > 0) {
               exec_cmd "%$2";
            } else {
               print "Nothing to do with $mytarget\n";
            }
         } else {
            #print "wildcard doesn't exist for $mytarget\n"
         }
      }
      else {
         my $dependency = $deps{$mytarget};
         # put a number that is not 1 or 2 because timeCompare returns 1 or 2
         # if firstTarget still equals 2 at the end, target's commands still needs to execute
         my $firstTarget = 2;
         foreach my $var (@$dependency) {
            $firstTarget = timeCompare ($mytarget, $var);
            # print "first target = $firstTarget\n";dd
            if ($firstTarget == 1) {
               #print "timeCompare ($mytarget, $var) = true\n";
               interp_target ($var);
            }
         }
         #print "executing_cmd on $mytarget\n";
         if ($firstTarget > 0) {
            exec_cmd $mytarget;
         } else {       # this one doesn't print all
            print "Nothing to do with \"$mytarget\"\n";
         }
      }
   }
}

my $length = @ARGV;
if ($length == 0) {
   interp_target $first_target;
}
elsif ($length == 1) {
   #print "1 arg detected\n";
   my $input_target = $ARGV[0];
   #print "$input_target detected\n";
   interp_target $input_target;
}
else {
   print";;;;ERROR too many args;;;;;\n";
}
