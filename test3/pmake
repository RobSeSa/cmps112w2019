#!/usr/bin/perl
# Robert Sato (rssato)
# Huanlei Wu (hwu43)

use strict;
use warnings;
use Getopt::Std;
my %OPTS;
getopts ("d", \%OPTS);
$0 =~ s|.*/||;

# signals and their description
my %strsignal = (
    1 => "Hangup",
    2 => "Interrupt",
    3 => "Quit",
    4 => "Illegal instruction",
    5 => "Trace/breakpoint trap",
    6 => "Aborted",
    7 => "Bus error",
    8 => "Floating point exception",
    9 => "Killed",
   11 => "Segmentation fault",
   13 => "Broken pipe",
   14 => "Alarm clock",
   15 => "Terminated",
   16 => "Stack fault",
   17 => "Child exited",
   18 => "Continued",
   19 => "Stopped (signal)",
   20 => "Stopped",
   21 => "Stopped (tty input)",
   22 => "Stopped (tty output)",
   24 => "CPU time limit exceeded",
   25 => "File size limit exceeded",
   26 => "Virtual timer expired",
   27 => "Profiling timer expired",
   28 => "Window changed",
   29 => "I/O possible",
   30 => "Power failure",
   31 => "Bad system call",
);

# sees if flag d is typed in command line
# if flag d is set, $opt_d will be true
getopts('d');

my %deps;       # hash table to store target and dependencies
my %commands;   # hash table to store target and commands
my %macro;      # hash table to store macros
my $target;     # keeps track of the target
my $first_flag = 1;
my $first_target;

# parses a line of the given file
# word before the colon is the target
# word(s) after the colon are the dependencies
sub replace {
   my ($line) = @_;
   while ($line =~ m/^.*?\${(.*?)}.*$/) {
      my $replaced = $macro{$1};
      $line =~ s/\${$1}/$replaced/g;
   }
   return $line;
}

sub targetAndDep ($) {
   my ($line) = @_;
   return undef unless $line =~ m/^(\S+)\s*:\s*(.*?)\s*$/;
   my $target = replace $1;
   my $dependency = replace $2;
   my @dependencies = split m/\s+/, $dependency;
   return $target, \@dependencies;
}

sub mtime($) {
   my ($filename) = @_;
   return undef unless defined $filename;
   my @stat = stat $filename;
   return @stat ? $stat[9] : undef;
}

sub getMacro ($) {
   my ($line) = @_;
   $line =~ m/^(\S+)\s*=\s*(.*?)\s*$/;
   my ($var, $val) = ($1, $2);
   my @values = split m/\s+/, $val;
   return $var, \@values;
}

# goes through the whole Makefile
# uses function parse_dep to parse each line of the file
open(FILE, 'Makefile') || die("Could not open Makefile\n");
while (my $line = <FILE>) {
   my $deps;
   # line is a comment
   if ($line =~ m/^#.*$/) {
      # do nothing
   # line contains a target and dependencies
   } elsif ($line =~ m/^\S+\s*:\s*.*?\s*$/) {
      ($target, $deps) = targetAndDep $line;
      $deps{$target} = $deps;
      if($first_flag) {
         $first_target = $target;
         $first_flag = 0;
      }
   # line contains macro
   } elsif ($line =~ m/^\S+\s*=\s*.*?\s*$/) {
      my ($var, $val) = getMacro $line;
      $macro{$var} = $val;
   # line contains command
   } elsif ($line =~ m/^\t(.*)\s*$/) {
      if (exists $commands{$target}) {
         my $array = $commands{$target};
         my $replaced = replace $1;
         push (@$array, $replaced);
         #print "pushing $1 into commands{$target}\n";
         $commands{$target} = $array;
      } else {
         my $replaced = replace $1;
         my @newArr = ($replaced);
         $commands{$target} = \@newArr;
         #print "HHHHHHHELLLLLLOOOOO $target\n";
      }
   }
}
close(FILE);

# compares given target with given dependency
sub timeCompare ($$) {
   my ($mytarget, $var) = (@_);
   my $target_time = mtime $mytarget;
   if($target_time){
      #print "$mytarget time = $target_time\n";
   }
   #if target time not defined target is just a target and not a file
   #therefore all of its dependencies and commands should be executed
   else {
      #print "$mytarget time is undefined\n";
      return 1;
   }
   my $var_time = mtime $var;
   #print "var: $var\n";
   #print "$var time = $var_time\n";
   if(! defined $var_time) {
      #print "$var does not exist\n";
      return 1;
   }
   else {
      my $difference = $var_time - $target_time;
      #print "difference: $difference\n";
      if($difference > 0){
         #print "$var needs to be compiled\n$var edited $difference after $mytarget\n";
         return 1;
      }
      else{
         #print "no need to recompile $var as $var edited $difference after $mytarget\n";
         return 0;
      }
   }
}

# compares all interior dependencies for time discrepancies
sub tree_time_cmp {
   my ($mytarget) = @_;
   if (! exists $deps{$mytarget}) {
      #print "\$deps{$mytarget} DNE returning 0..\n";
      return 0;
   } else {
      my $dependency = $deps{$mytarget};
      foreach my $var (@$dependency) {
         if (timeCompare ($mytarget, $var)) {
            return 1;
         } else {
            #print "\$var = $var\n";
            if (tree_time_cmp ($var)) {
               #print "tree_time_cmp $var was true!\n returning 1..\n";
               return 1;
            }
         }
      }
      return 0;
   }
}

sub exec_cmd {
   my ($target) = @_;
   #print "target = $target\n";
   my $command = $commands{$target};
   #print "size: $size\n";
   foreach my $var (@$command) {
      if (defined $var){
         #print "Executing commands: \"$var\" under target: $target\n";
         if ($var =~ m/^@\s*(.*?)\s*$/) {
            system($1);
         }
         elsif ($var =~ m/^-\s*(.*?)\s*$/) {
            print "$1\n";
            system($1);
         } else {
            print "$var\n";
            system ($var);
         }
      }
      else {
         #print "$target has no commands\n";
      }
   }
}

sub interp_target {
   my ($mytarget) = @_;
   #print "interpreting $mytarget...\n";
   if ((! exists $deps{$mytarget}) && (! defined $mytarget))  {
      print ";;;;;;;;;; ERROR ;;;;;;;;;;\n$mytarget not found in dep table or directory\n";
   }
   else {
      if (! exists $deps{$mytarget}) {
         print "$mytarget is not in deps table but in the directory\n";
      }
      else {
         my $dependency = $deps{$mytarget};
         foreach my $var (@$dependency) {
            if (timeCompare ($mytarget, $var)) {
               #print "timeCompare ($mytarget, $var) = true\n";
               interp_target ($var);
            }
         }
         #print "executing_cmd on $mytarget\n";
         exec_cmd $mytarget;
      }
   }
}

my $length = @ARGV;
if ($length == 0) {
   interp_target $first_target;
}
elsif ($length == 1) {
   #print "1 arg detected\n";
   my $input_target = $ARGV[0];
   #print "$input_target detected\n";
   interp_target $input_target;
}
else {
   #print";;;;ERROR too many args;;;;;\n";
}
#print "\$length = $length\n";
